{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Attendedsysupgrade Server for OpenWrt (GSoC 2017) \u00b6 This project intends to simplify the sysupgrade process of devices running OpenWrt or distributions based on the former like LibreMesh. The provided tools here offer an easy way to reflash the router with a new version or package upgrades, without the need of opkg installed. Additionally it offers an API (covered below) to request custom images with any selection of packages pre-installed, allowing to create firmware images without the need of setting up a build environment, even from mobile devices. Clients \u00b6 Yet another firmware selector \u00b6 Simple web interface using vanilla JavaScript currently developed by @mwarning. It offers a device search based on model names and show links either to official images or requests images via the asu API. Please join in the development at the GitHub repository LuCI app \u00b6 The package luci-app-attendedsysupgrade still exists but is currently not usable with the rewritten server implementation. The app will however be upgraded as soon as possible to be usable again. Server \u00b6 The server listens to image requests and automatically generate them if the request was valid. This is done by automatically setting up OpenWrt ImageBuilders and cache images in a Redis database. This allows to quickly respond to requests without rebuilding existing images again. Active server \u00b6 chef.libremesh.org Run your own server \u00b6 Redis is required to store image requests: sudo apt install redis-server tar Install asu : pip install asu Start the server via the following commands: export FLASK_APP=asu # set Flask app to asu flask janitor init # download upstream profiles/packages flask run # run development server Start the worker via the following comand: rq worker Production \u00b6 It is recommended to run ASU via gunicorn proxied by nginx . Find a possible nginx configuration in the misc/ folder. Also the setup should not HTTPS to allow clients without SSL/certificates to check for upgrades. To change the default setting place a file called config.py in the root of the instance folder . Find an example in the misc/ folder. pip install gunicorn gunicorn \"asu:create_app()\" Development \u00b6 After cloning this repository create a Python virtual environment and install the dependencies: python3 -m venv . source bin/activate pip install -r requirements.txt export FLASK_APP=asu # set Flask app to asu export FLASK_DEBUG=1 # run Flask in debug mode (autoreload) flask run API \u00b6 Upgrade check /api/versions \u00b6 The server does no longer offer complex upgrade but only serves static JSON files including available versions. For now the client must evaluate if the responded JSON contains a newer version. Build request /api/build \u00b6 key value information version SNAPSHOT installed version profile netgear_wndr4300-v2 board_name of ubus call system board packages [\"luci\", \"vim\"] Extra packages for the new image Each valid request returns a request_hash which can be used for future polling via /api/build/<request_hash> . Response status 200 \u00b6 A 200 response means the image was sucessfully created. The response is JSON encoded containing build information. key information bin_dir relative path to created files buildlog boolean if buildlog.txt was created manifest dict of all installed packages plus version request_hash hashed request data stored by the server { \"build_at\": \"Tue, 25 Feb 2020 08:49:48 GMT\", \"enqueued_at\": \"Tue, 25 Feb 2020 08:49:09 GMT\", \"id\": \"avm_fritzbox-4040\", \"image_prefix\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040\", \"images\": [ { \"name\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040-squashfs-eva.bin\", \"sha256\": \"8cb0d58bf672ed442f0813a1f04ec2f5edf6e2b64c8f117cb11158e19251aa0b\", \"type\": \"eva\" }, { \"name\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040-squashfs-sysupgrade.bin\", \"sha256\": \"0d12ce60dd63422a63ed28f0e2a2ab2d367a407ccc32b665c28c809f3cb073f1\", \"type\": \"sysupgrade\" } ], \"manifest\": { \"ath10k-firmware-qca4019-ct\": \"2019-10-03-d622d160-1\", \"base-files\": \"213-r12297-7e9c7e7b2d\", \"busybox\": \"1.31.1-1\", \"cgi-io\": \"17\", \"dnsmasq\": \"2.80-18\", [...] \"uclient-fetch\": \"2020-01-05-fef6d3d3-1\", \"uhttpd\": \"2020-02-12-2ee323c0-1\", \"urandom-seed\": \"1.0-1\", \"urngd\": \"2020-01-21-c7f7b6b6-1\", \"usign\": \"2019-09-21-f34a383e-1\", \"vim\": \"8.1-6\", \"wireless-regdb\": \"2019.06.03\", \"wpad-basic\": \"2019-08-08-ca8c2bd2-6\", \"zlib\": \"1.2.11-3\" }, \"metadata_version\": 1, \"request_hash\": \"5bac6cb8321f\", \"supported_devices\": [ \"avm,fritzbox-4040\" ], \"target\": \"ipq40xx/generic\", \"titles\": [ { \"model\": \"FRITZ!Box 4040\", \"vendor\": \"AVM\" } ], \"version_commit\": \"r12297-7e9c7e7b2d\", \"version_number\": \"SNAPSHOT\" } Response status codes \u00b6 The client should check the status code: status meaning information 200 build finish / upgrade available see parameters above 202 building, queued, imagebuilder setup building right now or in build queue 400 bad request see error parameter 404 not found if invalid request_hash supplied via /api/build/<request_hash> 422 unknown package unknown package in request 500 build failed see log for build log","title":"Attendedsysupgrade Server for OpenWrt (GSoC 2017)"},{"location":"#attendedsysupgrade-server-for-openwrt-gsoc-2017","text":"This project intends to simplify the sysupgrade process of devices running OpenWrt or distributions based on the former like LibreMesh. The provided tools here offer an easy way to reflash the router with a new version or package upgrades, without the need of opkg installed. Additionally it offers an API (covered below) to request custom images with any selection of packages pre-installed, allowing to create firmware images without the need of setting up a build environment, even from mobile devices.","title":"Attendedsysupgrade Server for OpenWrt (GSoC 2017)"},{"location":"#clients","text":"","title":"Clients"},{"location":"#yet-another-firmware-selector","text":"Simple web interface using vanilla JavaScript currently developed by @mwarning. It offers a device search based on model names and show links either to official images or requests images via the asu API. Please join in the development at the GitHub repository","title":"Yet another firmware selector"},{"location":"#luci-app","text":"The package luci-app-attendedsysupgrade still exists but is currently not usable with the rewritten server implementation. The app will however be upgraded as soon as possible to be usable again.","title":"LuCI app"},{"location":"#server","text":"The server listens to image requests and automatically generate them if the request was valid. This is done by automatically setting up OpenWrt ImageBuilders and cache images in a Redis database. This allows to quickly respond to requests without rebuilding existing images again.","title":"Server"},{"location":"#active-server","text":"chef.libremesh.org","title":"Active server"},{"location":"#run-your-own-server","text":"Redis is required to store image requests: sudo apt install redis-server tar Install asu : pip install asu Start the server via the following commands: export FLASK_APP=asu # set Flask app to asu flask janitor init # download upstream profiles/packages flask run # run development server Start the worker via the following comand: rq worker","title":"Run your own server"},{"location":"#production","text":"It is recommended to run ASU via gunicorn proxied by nginx . Find a possible nginx configuration in the misc/ folder. Also the setup should not HTTPS to allow clients without SSL/certificates to check for upgrades. To change the default setting place a file called config.py in the root of the instance folder . Find an example in the misc/ folder. pip install gunicorn gunicorn \"asu:create_app()\"","title":"Production"},{"location":"#development","text":"After cloning this repository create a Python virtual environment and install the dependencies: python3 -m venv . source bin/activate pip install -r requirements.txt export FLASK_APP=asu # set Flask app to asu export FLASK_DEBUG=1 # run Flask in debug mode (autoreload) flask run","title":"Development"},{"location":"#api","text":"","title":"API"},{"location":"#upgrade-check-apiversions","text":"The server does no longer offer complex upgrade but only serves static JSON files including available versions. For now the client must evaluate if the responded JSON contains a newer version.","title":"Upgrade check /api/versions"},{"location":"#build-request-apibuild","text":"key value information version SNAPSHOT installed version profile netgear_wndr4300-v2 board_name of ubus call system board packages [\"luci\", \"vim\"] Extra packages for the new image Each valid request returns a request_hash which can be used for future polling via /api/build/<request_hash> .","title":"Build request /api/build"},{"location":"#response-status-200","text":"A 200 response means the image was sucessfully created. The response is JSON encoded containing build information. key information bin_dir relative path to created files buildlog boolean if buildlog.txt was created manifest dict of all installed packages plus version request_hash hashed request data stored by the server { \"build_at\": \"Tue, 25 Feb 2020 08:49:48 GMT\", \"enqueued_at\": \"Tue, 25 Feb 2020 08:49:09 GMT\", \"id\": \"avm_fritzbox-4040\", \"image_prefix\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040\", \"images\": [ { \"name\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040-squashfs-eva.bin\", \"sha256\": \"8cb0d58bf672ed442f0813a1f04ec2f5edf6e2b64c8f117cb11158e19251aa0b\", \"type\": \"eva\" }, { \"name\": \"openwrt-387e9d003d04-ipq40xx-generic-avm_fritzbox-4040-squashfs-sysupgrade.bin\", \"sha256\": \"0d12ce60dd63422a63ed28f0e2a2ab2d367a407ccc32b665c28c809f3cb073f1\", \"type\": \"sysupgrade\" } ], \"manifest\": { \"ath10k-firmware-qca4019-ct\": \"2019-10-03-d622d160-1\", \"base-files\": \"213-r12297-7e9c7e7b2d\", \"busybox\": \"1.31.1-1\", \"cgi-io\": \"17\", \"dnsmasq\": \"2.80-18\", [...] \"uclient-fetch\": \"2020-01-05-fef6d3d3-1\", \"uhttpd\": \"2020-02-12-2ee323c0-1\", \"urandom-seed\": \"1.0-1\", \"urngd\": \"2020-01-21-c7f7b6b6-1\", \"usign\": \"2019-09-21-f34a383e-1\", \"vim\": \"8.1-6\", \"wireless-regdb\": \"2019.06.03\", \"wpad-basic\": \"2019-08-08-ca8c2bd2-6\", \"zlib\": \"1.2.11-3\" }, \"metadata_version\": 1, \"request_hash\": \"5bac6cb8321f\", \"supported_devices\": [ \"avm,fritzbox-4040\" ], \"target\": \"ipq40xx/generic\", \"titles\": [ { \"model\": \"FRITZ!Box 4040\", \"vendor\": \"AVM\" } ], \"version_commit\": \"r12297-7e9c7e7b2d\", \"version_number\": \"SNAPSHOT\" }","title":"Response status 200"},{"location":"#response-status-codes","text":"The client should check the status code: status meaning information 200 build finish / upgrade available see parameters above 202 building, queued, imagebuilder setup building right now or in build queue 400 bad request see error parameter 404 not found if invalid request_hash supplied via /api/build/<request_hash> 422 unknown package unknown package in request 500 build failed see log for build log","title":"Response status codes"},{"location":"reference/common/","text":"get_file_hash(path) \u00b6 Show source code in /asu/common.py def get_file_hash(path: str) -> str: \"\"\"Return sha256sum of given path Args: path (str): path to file Returns: str: hash of file \"\"\" BLOCK_SIZE = 65536 h = hashlib.sha256() with open(path, \"rb\") as f: fb = f.read(BLOCK_SIZE) while len(fb) > 0: h.update(fb) fb = f.read(BLOCK_SIZE) return h.hexdigest() Return sha256sum of given path Parameters Name Type Description Default path str path to file required Returns Type Description str str: hash of file get_packages_hash(packages) \u00b6 Show source code in /asu/common.py def get_packages_hash(packages: list) -> str: \"\"\"Return sha256sum of package list Duplicate packages are automatically removed and the list is sorted to be reproducible Args: packages (list ): list of packages Returns: str: hash of `request_data` \"\"\" return get_str_hash(\" \".join(sorted(list(set(packages)))), 12) Return sha256sum of package list Duplicate packages are automatically removed and the list is sorted to be reproducible Parameters Name Type Description Default packages list list of packages required Returns Type Description str str: hash of request_data get_request_hash(request_data) \u00b6 Show source code in /asu/common.py def get_request_hash(request_data: dict) -> str: \"\"\"Return sha256sum of an image request Creates a reproducible hash of the request by sorting the arguments Args: request_data (dict): dict contianing request information Returns: str: hash of `request_data` \"\"\" request_data[\"packages_hash\"] = get_packages_hash(request_data.get(\"packages\", \"\")) request_array = [ request_data.get(\"distro\", \"\"), request_data.get(\"version\", \"\"), request_data.get(\"profile\", \"\"), request_data[\"packages_hash\"], str(request_data.get(\"packages_diff\", 0)), ] return get_str_hash(\" \".join(request_array), 12) Return sha256sum of an image request Creates a reproducible hash of the request by sorting the arguments Parameters Name Type Description Default request_data dict dict contianing request information required Returns Type Description str str: hash of request_data get_str_hash(string, length=32) \u00b6 Show source code in /asu/common.py def get_str_hash(string: str, length: int = 32) -> str: \"\"\"Return sha256sum of str with optional length Args: string (str): input string length (int): hash length Returns: str: hash of string with specified length \"\"\" h = hashlib.sha256() h.update(bytes(string, \"utf-8\")) response_hash = h.hexdigest()[:length] return response_hash Return sha256sum of str with optional length Parameters Name Type Description Default string str input string required length int hash length 32 Returns Type Description str str: hash of string with specified length verify_usign(sig_file, msg_file, pub_key) \u00b6 Show source code in /asu/common.py def verify_usign(sig_file: Path, msg_file: Path, pub_key: str) -> bool: \"\"\"Verify a signify/usign signature This implementation uses pynacl Args: sig_file (Path): signature file msg_file (Path): message file to be verified pub_key (str): public key to use for verification Returns: bool: Sucessfull verification Todo: Currently ignores keynum and pkalg \"\"\" pkalg, keynum, pubkey = struct.unpack(\"!2s8s32s\", base64.b64decode(pub_key)) sig = base64.b64decode(sig_file.read_text().splitlines()[-1]) pkalg, keynum, sig = struct.unpack(\"!2s8s64s\", sig) verify_key = nacl.signing.VerifyKey(pubkey, encoder=nacl.encoding.RawEncoder) try: verify_key.verify(msg_file.read_bytes(), sig) return True except nacl.exceptions.CryptoError: return False Verify a signify/usign signature This implementation uses pynacl Parameters Name Type Description Default sig_file Path signature file required msg_file Path message file to be verified required pub_key str public key to use for verification required Returns Type Description bool bool: Sucessfull verification Todo Currently ignores keynum and pkalg","title":"Common"},{"location":"reference/common/#asu.common.get_file_hash","text":"Show source code in /asu/common.py def get_file_hash(path: str) -> str: \"\"\"Return sha256sum of given path Args: path (str): path to file Returns: str: hash of file \"\"\" BLOCK_SIZE = 65536 h = hashlib.sha256() with open(path, \"rb\") as f: fb = f.read(BLOCK_SIZE) while len(fb) > 0: h.update(fb) fb = f.read(BLOCK_SIZE) return h.hexdigest() Return sha256sum of given path Parameters Name Type Description Default path str path to file required Returns Type Description str str: hash of file","title":"get_file_hash()"},{"location":"reference/common/#asu.common.get_packages_hash","text":"Show source code in /asu/common.py def get_packages_hash(packages: list) -> str: \"\"\"Return sha256sum of package list Duplicate packages are automatically removed and the list is sorted to be reproducible Args: packages (list ): list of packages Returns: str: hash of `request_data` \"\"\" return get_str_hash(\" \".join(sorted(list(set(packages)))), 12) Return sha256sum of package list Duplicate packages are automatically removed and the list is sorted to be reproducible Parameters Name Type Description Default packages list list of packages required Returns Type Description str str: hash of request_data","title":"get_packages_hash()"},{"location":"reference/common/#asu.common.get_request_hash","text":"Show source code in /asu/common.py def get_request_hash(request_data: dict) -> str: \"\"\"Return sha256sum of an image request Creates a reproducible hash of the request by sorting the arguments Args: request_data (dict): dict contianing request information Returns: str: hash of `request_data` \"\"\" request_data[\"packages_hash\"] = get_packages_hash(request_data.get(\"packages\", \"\")) request_array = [ request_data.get(\"distro\", \"\"), request_data.get(\"version\", \"\"), request_data.get(\"profile\", \"\"), request_data[\"packages_hash\"], str(request_data.get(\"packages_diff\", 0)), ] return get_str_hash(\" \".join(request_array), 12) Return sha256sum of an image request Creates a reproducible hash of the request by sorting the arguments Parameters Name Type Description Default request_data dict dict contianing request information required Returns Type Description str str: hash of request_data","title":"get_request_hash()"},{"location":"reference/common/#asu.common.get_str_hash","text":"Show source code in /asu/common.py def get_str_hash(string: str, length: int = 32) -> str: \"\"\"Return sha256sum of str with optional length Args: string (str): input string length (int): hash length Returns: str: hash of string with specified length \"\"\" h = hashlib.sha256() h.update(bytes(string, \"utf-8\")) response_hash = h.hexdigest()[:length] return response_hash Return sha256sum of str with optional length Parameters Name Type Description Default string str input string required length int hash length 32 Returns Type Description str str: hash of string with specified length","title":"get_str_hash()"},{"location":"reference/common/#asu.common.verify_usign","text":"Show source code in /asu/common.py def verify_usign(sig_file: Path, msg_file: Path, pub_key: str) -> bool: \"\"\"Verify a signify/usign signature This implementation uses pynacl Args: sig_file (Path): signature file msg_file (Path): message file to be verified pub_key (str): public key to use for verification Returns: bool: Sucessfull verification Todo: Currently ignores keynum and pkalg \"\"\" pkalg, keynum, pubkey = struct.unpack(\"!2s8s32s\", base64.b64decode(pub_key)) sig = base64.b64decode(sig_file.read_text().splitlines()[-1]) pkalg, keynum, sig = struct.unpack(\"!2s8s64s\", sig) verify_key = nacl.signing.VerifyKey(pubkey, encoder=nacl.encoding.RawEncoder) try: verify_key.verify(msg_file.read_bytes(), sig) return True except nacl.exceptions.CryptoError: return False Verify a signify/usign signature This implementation uses pynacl Parameters Name Type Description Default sig_file Path signature file required msg_file Path message file to be verified required pub_key str public key to use for verification required Returns Type Description bool bool: Sucessfull verification Todo Currently ignores keynum and pkalg","title":"verify_usign()"}]}